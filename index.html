<!doctype html>
<html>

<head>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@600&display=swap" rel="stylesheet">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Comfortaa&display=swap" rel="stylesheet">
	<script src="https://pixijs.download/release/pixi.js"></script>
</head>
<p id="debug">Debug Data</p>

<body>

	<script>
		function Fonts() {
			this.Primary_font = "Comfortaa";
			this.Secondary_font = "Montserrat"
		}
		const num_balls = 500;
		var Primary_font = new Fonts().Primary_font;
		//const Secondary_font = "Monserrat";
		var Secondary_font = new Fonts().Secondary_font
		let app = new PIXI.Application({
			width: 768,
			height: 768,
			antialias: true,
			backgroundColor: 0x070707,
		});
		app.boundsPadding = 0;
		const loader = new PIXI.Loader();
		const Container = new PIXI.Container();
		// init ball vars
		let r = 5; // the radius of the ball
		let width = app.renderer.width, height = app.renderer.height - (r * 2); // the width and height of the app with safe space for the balls
		let min_x = r, max_x = width - (r * 2);
		let min_y = r, max_y = height - r;
		class Vector {
			constructor(angle, magnitude) {
				this.angle = angle;
				this.magnitude = magnitude;
				this.xMagnitude = magnitude * Math.cos(angle);
				this.yMagnitude = magnitude * Math.sin(angle * -1);
			}
		}
		class ballInfo {
			constructor(r, x, y, vector, color, seed) {
				this.r = r
				this.x = x;
				this.y = y;
				this.vector = vector;
				this.color = color;
				this.seed = seed;
			}
		}
		class Mouse {
			constructor(x, y, down, up) {
				this.x = x;
				this.y = y;
				this.down = down;
				this.up = up;
			}
		}
		var logo = PIXI.Sprite.from('./LOGO.png');
		logo.anchor.set(0.5);
		logo.width = 256;
		logo.height = 256;
		logo.tint = 0xFFD700
		app.stage.hitArea = app.screen;
		app.stage.interactive = true;
		bringToFront(logo)
		let vect = new Vector();
		let mousePos = new Mouse(0, 0, false, true);
		app.stage.on('mousemove', function (e) {
			mousePos.x = e.data.global.x;
			mousePos.y = e.data.global.y;
		});
		var balls = new Array(num_balls)
		window.onresize = function () { resize_handler(); }
		resize_handler();
		function resize_handler() {
			app.renderer.resize(window.innerWidth - 15, window.innerHeight);
			width = app.renderer.width;
			height = app.renderer.height - (r * 2);
			max_y = height - r;
			max_x = width - r;
		}
		for (let i = 0; i < balls.length; i++) {
			var _r = 0.5 + Math.random() * 1.5;
			tmp_vect = new Vector(rad(Math.random() * 360), (Math.random() * 8) / 50); // all math is in radians
			balls[i] = new ballInfo(
				_r,
				Math.floor(Math.random() * width),
				Math.floor(Math.random() * height),
				tmp_vect,
				0xf2f2f2,
				Math.random() * num_balls);
		}
		document.body.appendChild(app.view);
		let title = new PIXI.Text(
			'ROBOTICS',
			{
				fontFamily: Primary_font,
				fontSize: 50,
				fill: 0xf2f2f2,
			}
		);
		let subtitle = new PIXI.Text(
			'CENTRAL FLORIDA',
			{
				fontFamily: Primary_font,
				fontSize: 50,
				fill: 0xf2f2f2,
			}
		);
		title.resolution = 2;
		title.anchor.set(0.5);
		subtitle.resolution = 2;
		subtitle.anchor.set(0.5);
		let graphics = new PIXI.Graphics();
		let line = new PIXI.Graphics();
		let glowgrafx = new PIXI.Graphics();
		var k = 0;
		app.ticker.add((delta) => {
			glowgrafx.clear();
			graphics.clear();
			line.clear();

			Buttons();
			BallPhysics(delta);
			CursorHandler(delta);
			title.position.x = width / 2;
			title.position.y = (height / 2) - 140;
			subtitle.position.x = width / 2;
			subtitle.position.y = (height / 2) + 140;
			logo.position.x = width / 2;
			logo.position.y = height / 2;
			app.stage.addChild(graphics, line, title, subtitle, logo);

		});
		var AboutText = new PIXI.Text(
			"ABOUT",
			{
				fontFamily: Secondary_font,
				fontSize: 24,
				fill: 0xf2f2f2,
			}
		);
		var OfficersText = new PIXI.Text(
			"OFFICERS",
			{
				fontFamily: Secondary_font,
				fontSize: 24,
				fill: 0xf2f2f2,
			}
		);
		class Point {
			constructor(x, y) {
				this.x = x;
				this.y = y;
			}
			set(a) {
				this.x = a;
				this.y = a;
			}
		}
		class Button {
			constructor(xPos, yPos, BWidth, BHeight, textObj) {
				this.ButtonRend = new PIXI.Graphics();
				this.position = new Point(xPos, yPos);
				this.BWidth = BWidth;
				this.BHeight = BHeight;
				this.textObj = textObj;
				this.Width = xPos + BWidth
			}
			Render() {
				this.ButtonRend.clear();
				this.ButtonRend.interactive = true;
				this.ButtonRend.lineStyle(1, 0xf2f2f2);
				this.ButtonRend.drawRect(
					this.position.x,
					this.position.y,
					this.BWidth,
					this.BHeight,
				);
				this.ButtonRend.hitArea = PIXI.Rectangle(this.position.x, this.position.y, this.BWidth + this.position.x, this.BHeight + this.position.y);
				this.textObj.anchor.set(0.5);
				this.textObj.position.x = this.position.x + (this.BWidth / 2)
				this.textObj.position.y = this.position.y + (this.BHeight / 2)
				app.stage.addChild(this.ButtonRend, this.textObj);
			}
		}
		var AboutButton = new Button(20, 20, 160, 40, AboutText);
		var OfficersButton = new Button(AboutButton.Width + 40, AboutButton.position.y, AboutButton.BWidth, AboutButton.BHeight, OfficersText);
		function Buttons() {
			AboutButton.Render();
			OfficersButton.Render();
		}
		let cursorRadius = 70;
		let linecolor = 0xf2f2f2;
		function CursorHandler(delta) {
			graphics.lineStyle(0);
			graphics.beginFill(0xf2f2f2)

			//detect if the all is within the radius of the cursor

			balls.forEach(ball => {
				if (distancetocursor(ball.x, ball.y) < cursorRadius) {
					ball.color = 0xFFD700;
					Glow(ball.x, ball.y, 0xFFD700, 4, 3, true);
					line.position = new PIXI.Point(0, 0);
					line.lineStyle(0.5 / map(distancetocursor(ball.x, ball.y), 0, 70, 0, 1), linecolor)
					line.moveTo(ball.x, ball.y);
					line.lineTo(mousePos.x, mousePos.y);
					if (mousePos.down) {
						Glow(mousePos.x, mousePos.y, 0xFFD700, 2, 5, true);
						linecolor = 0xFFD700;
						ball.x = lerp(ball.x, mousePos.x, delta / 100);
						ball.y = lerp(ball.y, mousePos.y, delta / 100);
					}
					else {
						Glow(mousePos.x, mousePos.y, 0x4a4a4a, 2, 5, true);
						linecolor = 0xf2f2f2;
					}
				}
				else {
					ball.color = 0xf2f2f2;
				}
			});
			function distancetocursor(ballx, bally) {
				return Math.sqrt(Math.pow(mousePos.x - ballx, 2) + Math.pow(mousePos.y - bally, 2));
			}
		}
		app.stage.on("mousedown", function (e) {
			mousePos.down = true;
			mousePos.up = false;
		});//mouse is currently down, and on the canvas
		app.stage.on("mouseup", function (e) {
			mousePos.down = false;
			mousePos.up = true;
		}); // mouse has let go




		function BallPhysics(delta) {
			for (let i = 0; i < num_balls; i++) { // init multiple balls
				//handle collisions with the walls and such
				if (deg(balls[i].vector.angle) < 0) {
					balls[i].vector = new Vector(rad(deg(balls[i].vector.angle) + 360), balls[i].vector.magnitude)
				}

				if (balls[i].x > max_x + (2 * r)) { // right wall
					if (deg(balls[i].vector.angle) > 0 && deg(balls[i].vector.angle) < 90) {
						balls[i].vector = new Vector(rad(180 - Math.abs(deg(balls[i].vector.angle) + 360)), balls[i].vector.magnitude);
					} else if (deg(balls[i].vector.angle) > 270 && deg(balls[i].vector.angle) < 360) {
						balls[i].vector = new Vector(rad(180 + Math.abs(deg(balls[i].vector.angle) - 360)), balls[i].vector.magnitude);
					}
				}
				else if (balls[i].x < (r * -2)) { // left wall
					//balls[i].color = 0xA6763C;
					if (deg(balls[i].vector.angle) > 90 && deg(balls[i].vector.angle) < 180) {
						balls[i].vector = new Vector(rad(180 - Math.abs(deg(balls[i].vector.angle) + 360)), balls[i].vector.magnitude);
					} else if (deg(balls[i].vector.angle) > 180 && deg(balls[i].vector.angle) < 270) {
						balls[i].vector = new Vector(rad(180 + Math.abs(deg(balls[i].vector.angle) - 360)), balls[i].vector.magnitude);
					}
				}
				else if (balls[i].y > max_y + (4 * r)) { // floor
					//balls[i].color = 0x0D0D0D;
					if (deg(balls[i].vector.angle) > 270 && deg(balls[i].vector.angle) < 360) {
						balls[i].vector = new Vector(rad(Math.abs(deg(balls[i].vector.angle) - 360)), balls[i].vector.magnitude);
					}
					else if ((deg(balls[i].vector.angle) > 180 && deg(balls[i].vector.angle) < 270)) {
						balls[i].vector = new Vector(rad(Math.abs(deg(balls[i].vector.angle) - 360)), balls[i].vector.magnitude);
					}
				}
				else if (balls[i].y < (r * -2)) { // ceiling
					//balls[i].color = 0x0D0D0D;
					if (deg(balls[i].vector.angle) > 0 && deg(balls[i].vector.angle) < 90) {
						balls[i].vector = new Vector(rad(Math.abs(deg(balls[i].vector.angle) - 360)), balls[i].vector.magnitude);
					}
					else if (deg(balls[i].vector.angle) > 90 && deg(balls[i].vector.angle) < 180) {
						balls[i].vector = new Vector(rad(Math.abs(deg(balls[i].vector.angle) - 360)), balls[i].vector.magnitude);
					}
				}
				// apply vector magnitudes to the balls
				balls[i].x += balls[i].vector.xMagnitude; //change the x depending on the vector
				balls[i].y += balls[i].vector.yMagnitude; //change the y depending on the vector
				k += delta / 300000;
				graphics.lineStyle(0);
				graphics.beginFill(balls[i].color, (1 / 3) * Math.cos(k + balls[i].seed) + (2 / 3));
				graphics.drawCircle(balls[i].x, balls[i].y, balls[i].r);
				graphics.endFill();
			}
		}
		function bringToFront(sprite, parent) {
			var sprite = (typeof (sprite) != "undefined") ? sprite.target || sprite : this; var parent = parent || sprite.parent || { "children": false }; if (parent.children) {
				for (var keyIndex in sprite.parent.children) {
					if (sprite.parent.children[keyIndex] === sprite) {
						sprite.parent.children.splice(keyIndex, 1); break;
					}
				} parent.children.push(sprite);
			}
		}
		function sendToBack(sprite, parent) {
			var sprite = (typeof (sprite) != "undefined") ? sprite.target || sprite : this; var parent = parent || sprite.parent || { "children": false }; if (parent.children) {
				for (var keyIndex in sprite.parent.children) {
					if (sprite.parent.children[keyIndex] === sprite) {
						sprite.parent.children.splice(keyIndex, 1); break;
					}
				} parent.children.splice(0, 0, sprite);
			}
		}
		function Glow(x, y, color, resolution, radius, enable) {
			if (enable) {
				let step = radius / resolution;
				for (let i = 0; i < resolution; i++) {
					glowgrafx.lineStyle(0);
					glowgrafx.beginFill(color, (1 / resolution));
					glowgrafx.drawCircle(x, y, step);
					step = step + step;
				}
				app.stage.addChild(glowgrafx);
			}
		}
		function deg(rad) {
			return (rad * 180) / Math.PI;
		}
		function rad(deg) {
			return (deg * Math.PI) / 180
		}
		function Hex(int) {
			return int.toString(16);
		}
		function Int(hex) {
			return parseInt(hex, 16);
		}
		function lerp(v0, v1, t) {
			return v0 * (1 - t) + v1 * t
		}
		function map(x, in_min, in_max, out_min, out_max) {
			return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
		}
	</script>
</body>

</html>